---
title: "MiRNA-Pipeline report"
subtitle: "QC and basic stats"
author: "Daniel Fischer"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 4
    toc_float:
      toc_collapsed: true
    number_sections: true
    theme: lumen
    df_print: paged
    code_folding: show
---

```{r setup, include=FALSE}
#.libPaths(c("/projappl/project_2001746/R/libraries", .libPaths()))
#library("knitr")
library("GenomicTools")
library("xtable")   # Needed for LaTeX output of the tables
library("viridis")  # Needed for the colouring of the plots
library("rjson")    # Needed for multiqc dgsb etail data
library("DT")
library("kableExtra")
#library("edgeR")
library("ICS")
library("tsne")
library("lle")
library("kernlab")
#library("destiny")  # This is needed for diffusion maps. 
#library("plotly")   # This is for looping over ggplots and print them
options(scipen=999,
        stringsAsFactors=FALSE)
knitr::opts_chunk$set(echo = FALSE,
                      cache = FALSE,
                      cache.lazy = FALSE,
                      dev = c('png', 'pdf'),
                      fig.align = 'center', fig.height = 5, fig.width = 8.5)
# To run locally on terminal type this command in the pipeline folder:
# R -e "rmarkdown::render('./scripts/workflow-report.Rmd',output_file='./finalReport.html')"

if(!is.element("snakemake",ls())){
  projFolder <- "/scratch/project_2001310/MaitoInno_Feeding/"
  pipelineFolder <- "/scratch/project_2001310/Pipeline-miRNA"
  pipelineConfig <- "/scratch/project_2001310/MaitoInno_Feeding/miRNA-pipeline_config-feeding.yaml"
  serverConfig <- "/scratch/project_2001310/Pipeline-miRNA/miRNA-pipeline_puhti-config.yaml"
  refGenome.file <- "/scratch/project_2001310/MaitoInno_Feeding/References/ARS_UCD1.2/Bos_taurus.ARS-UCD1.2.dna.primary_assembly.fa"
  refAnnot.file <- "/scratch/project_2001310/MaitoInno_Feeding/References/ARS_UCD1.2/Bos_taurus.ARS-UCD1.2.95.gtf"
}
refGenome.fullPath <- refGenome.file
refGenome.file <- basename(refGenome.file)
ifelse(refGenome.file == "", refAvail <- FALSE, refAvail <- TRUE)
bowtieRefAlignment <- FALSE
```

```{r, include=FALSE}
# Init Step to make sure that the dependencies are loaded
htmltools::tagList(datatable(cars))
#htmltools::tagList(ggplotly(ggplot()))
```

```{r helpFunctions, include=FALSE}
# folder: referes to the FASTQ subfolder, e.g. tRNA, PhiX, etc
# mode: referes to the statistic, either wcl (for wc lines = reads) or wcc (for wc characters=bases)

getReadCounts <- function(folder, mode){  
  unmapped.files <- list.files(file.path(projFolder, "FASTQ",folder, "unmapped"), pattern=paste0("*.", mode))
  mapped.files <- list.files(file.path(projFolder, "FASTQ",folder, "mapped"), pattern=paste0("*.", mode))  

  unmapped <- c()
  mapped <- c()
  

  for(i in 1:length(unmapped.files)){
    unmapped[i] <- read.table(file.path(projFolder, "FASTQ", folder, "unmapped", unmapped.files[i]))[1,1]
  }

  for(i in 1:length(mapped.files)){
    mapped[i] <- read.table(file.path(projFolder, "FASTQ", folder, "mapped", mapped.files[i]))[1,1]
  }

  names(unmapped) <- unmapped.files
  names(mapped) <- mapped.files

  if(mode=="wcl"){
    unmapped <- unmapped / 4
    mapped <- mapped / 4
  }
  
  list(unmapped = unmapped,
       mapped = mapped)
}
```


# General workflow

## Directed acyclic graph (DAG)

The DAG of the used pipeline with rule dependencies.

```{r import workflow, echo=FALSE, fig.cap="Overview of the applied workflow", out.width = '100%'}
if(file.exists(file.path(projFolder,"workflow.png"))) knitr::include_graphics(file.path(projFolder,"workflow.png"))
```

# Basic stats

```{r get pipeline version}
pipeSMK <- readLines(file.path(pipelineFolder,"miRNA-pipeline.smk"))
pipeVersion <- gsub("##### Version: ","",pipeSMK[grep("##### Version:", pipeSMK)])[1]
if(file.exists(file.path(projFolder, "sampleInfo.txt"))){
    sampleInfo <- read.table(file.path(projFolder, "sampleInfo.txt"), header=TRUE)
    sampleInfo.avail <- TRUE
} else {
  sampleInfo <- data.frame(var=0, None=0)
    sampleInfo.avail <- FALSE
}

```

```{r import barcodesID, results="asis"}
rawsamples <- as.vector(as.matrix(read.table(file.path(projFolder, "rawsamples"))))
samples <- as.vector(as.matrix(read.table(file.path(projFolder, "samples"), header=FALSE)))

out <- data.frame(c("Project folder",
                    "Number of raw-samples",
                    "Number of samples (after concatenating)",
                    "Used reference genome",
                    "Used annotation file",
                    "No. of grouping information",
                    "Grouping names",
                    "Pipeline version"),
                  c(projFolder,
                    length(rawsamples),
                    length(samples),
                    basename(refGenome.file),
                    basename(refAnnot.file),
                    ncol(sampleInfo)-1,
                    paste(colnames(sampleInfo)[-1],collapse=", "),
                    pipeVersion))

out_html <- knitr::kable(out, col.names = NULL, "html")
kable_styling(out_html, "striped", position = "left")
```

# Quality checks

## Concatenating stats
As the concatenating is a crucial step in this pipeline, it is important to make this correct. As a double check that things went right, we check how
many raw samples were concatenated per sample. We do this visually. Basically, the height of the bars should correspond to your number of used lanes,
normally 1,2 or 4. Sometimes, you might want to concatenate also more files together (e.g. technical replicates), in this case the bar can be also higher.

```{r import the conc report files}
conc.reports.files <- list.files(file.path(projFolder, "FASTQ", "CONCATENATED"), pattern="*.report")

conc.reports <- list()
conc.reports[[1]] <- read.table(file.path(projFolder, "FASTQ", "CONCATENATED", conc.reports.files[1]))

for(i in 2:length(conc.reports.files)){
  conc.reports[[i]]<- read.table(file.path(projFolder, "FASTQ", "CONCATENATED", conc.reports.files[i]))
}
```

```{r visualize concatenation reports}
par(oma=c(6,5,0,0))
labels <- gsub(".fastq.gz.report","",conc.reports.files)
barplot(sapply(conc.reports,nrow), ylab="Concatenated files", names=labels, las=2)
```

## Sequencing depth
Importing the sequencing depths from RAW data and then check the trimming as well as concatenating stats

### Raw, lane-wise reads
```{r}
raw.read.files <- list.files(file.path(projFolder, "FASTQ", "RAW"), pattern="*.wcl")

raw.reads <- c()
for(i in 1:length(raw.read.files)){
  raw.reads[i] <- read.table(file.path(projFolder, "FASTQ", "RAW", raw.read.files[i]))[1,1]
}

names(raw.reads) <- raw.read.files
raw.reads <- raw.reads / 4
```

```{r}
par(mar=c(15,5,2,0))
barplot(raw.reads, las=2, main="Raw, lane-wise reads", col=4)
```

### Trimmed, lane-wise reads

```{r}
trimmed.read.files <- list.files(file.path(projFolder, "FASTQ", "TRIMMED"), pattern="*trimmed.wcl")

trimmed.reads <- c()
for(i in 1:length(trimmed.read.files)){
  trimmed.reads[i] <- read.table(file.path(projFolder, "FASTQ", "TRIMMED", trimmed.read.files[i]))[1,1]
}

names(trimmed.reads) <- trimmed.read.files
trimmed.reads <- trimmed.reads / 4
```

```{r}
par(mar=c(15,5,2,0))
barplot(trimmed.reads, las=2, main="Trimmed, lane-wise reads", col=7)
```

### Raw and trimmed, lane-wise reads

```{r}
par(mar=c(15,5,2,8), xpd=TRUE)
barplot(rbind(raw.reads,trimmed.reads), beside=TRUE, las=2, main="Raw and Trimmed, lane-wise reads", col=c(4,7))
legend("topright", inset=c(-0.2,0), legend=c("Raw","Trimmed"), fill=c(4,7))
```

### Concatenated reads

```{r}
conc.read.files <- list.files(file.path(projFolder, "FASTQ", "CONCATENATED"), pattern="*.wcl")

conc.reads <- c()
for(i in 1:length(conc.read.files)){
  conc.reads[i] <- read.table(file.path(projFolder, "FASTQ", "CONCATENATED", conc.read.files[i]))[1,1]
}

names(conc.reads) <- conc.read.files
conc.reads <- conc.reads / 4
```

```{r}
par(mar=c(15,6,2,0))
barplot(conc.reads, las=2, main="Concatenated reads", col=4)
```


## Sequenced bases
### Raw, lane-wise bases
```{r}
raw.bases.files <- list.files(file.path(projFolder, "FASTQ", "RAW"), pattern="*.wcc")

raw.bases <- c()
for(i in 1:length(raw.bases.files)){
  raw.bases[i] <- read.table(file.path(projFolder, "FASTQ", "RAW", raw.bases.files[i]))[1,1]
}

names(raw.bases) <- raw.bases.files
```

```{r}
par(mar=c(15,6,2,0))
barplot(raw.bases, las=2, main="Raw, lane-wise bases", col=4)
```
```{r}
par(mar=c(15,6,2,0))
barplot(raw.bases/raw.reads, las=2, main="Raw, lane-wise bases per read", col=4)
```
### Trimmed, lane-wise bases
```{r}
trimmed.bases.files <- list.files(file.path(projFolder, "FASTQ", "TRIMMED"), pattern="*trimmed.wcc")

trimmed.bases <- c()
for(i in 1:length(trimmed.bases.files)){
  trimmed.bases[i] <- read.table(file.path(projFolder, "FASTQ", "TRIMMED", trimmed.bases.files[i]))[1,1]
}

names(trimmed.bases) <- trimmed.bases.files
```

```{r}
par(mar=c(15,6,2,0))
barplot(trimmed.bases, las=2, main="Trimmed, lane-wise bases", col=4)
```

```{r}
par(mar=c(15,6,2,0))
barplot(raw.bases-trimmed.bases, las=2, main="Number of trimmed bases per lane", col=4)
```

```{r}
par(mar=c(15,6,2,0))
barplot(trimmed.bases/trimmed.reads, las=2, main="Trimmed, lane-wise bases per read", col=4)
```

### Raw and trimmed, lane-wise reads

```{r}
par(mar=c(15,5,2,8), xpd=TRUE)
barplot(rbind(raw.bases,trimmed.bases), beside=TRUE, las=2, main="Raw and Trimmed, lane-wise bases", col=c(4,7))
legend("topright", inset=c(-0.2,0), legend=c("Raw","Trimmed"), fill=c(4,7))
```

```{r}
par(mar=c(15,5,2,8), xpd=TRUE)
plotThis <- rbind(raw.bases/raw.reads,
                  trimmed.bases/trimmed.reads)
barplot(plotThis, beside=TRUE, las=2, main="Avg read length in bases", col=c(4,7))
legend("topright", inset=c(-0.2,0), legend=c("Raw","Trimmed"), fill=c(4,7))
```

### Concatenated bases

```{r}
conc.bases.files <- list.files(file.path(projFolder, "FASTQ", "CONCATENATED"), pattern="*.wcc")

conc.bases <- c()
for(i in 1:length(conc.bases.files)){
  conc.bases[i] <- read.table(file.path(projFolder, "FASTQ", "CONCATENATED", conc.bases.files[i]))[1,1]
}

names(conc.bases) <- conc.bases.files
```

```{r}
par(mar=c(15,6,2,0))
barplot(conc.bases, las=2, main="Concatenated Bases", col=4)
```

# Contamination removal

## tRNA

### Reads
Before aligning the data against the various mirDB references as well as the reference genome, we align the reads against a tRNA database and only proceed with those that do not align there.

```{r}
tmp <- getReadCounts("tRNA", mode="wcl")
trna.unmapped.reads <- tmp$unmapped
trna.mapped.reads <- tmp$mapped
```

```{r}
par(mar=c(15,6,2,8), xpd=TRUE)
barplot(rbind(conc.reads,trna.unmapped.reads, trna.mapped.reads), beside=TRUE, las=2, main="Concatenated and tRNA reads", col=c(4,5,6))
legend("topright", inset=c(-0.2,0), legend=c("Conc.","tRNA (unmapped)", "tRNA (mapped)"), fill=c(4,5,6))
```

### Bases
```{r}
tmp <- getReadCounts("tRNA", mode="wcc")
trna.unmapped.bases <- tmp$unmapped
trna.mapped.bases <- tmp$mapped
```

```{r}
par(mar=c(15,6,2,8), xpd=TRUE)
barplot(rbind(conc.bases,trna.unmapped.bases, trna.mapped.bases), beside=TRUE, las=2, main="Concatenated and tRNA bases", col=c(4,5,6))
legend("topright", inset=c(-0.2,0), legend=c("Conc.","tRNA (unmapped)", "tRNA (mapped)"), fill=c(4,5,6))
```


## PhiX
Further, we align reads that do not map against the tRNA database also against a PhiX genome and those reads that do not align against this reference, we use then for the downstream analysis

### Reads
```{r}

tmp <- getReadCounts("PhiX", mode="wcl")
phix.unmapped.reads <- tmp$unmapped
phix.mapped.reads <- tmp$mapped

```

```{r}
par(mar=c(15,6,2,8), xpd=TRUE)
barplot(rbind(trna.unmapped.reads,phix.unmapped.reads, phix.mapped.reads), beside=TRUE, las=2, main="tRNA filtered and PhiX reads", col=c(4,5,6))
legend("topright", inset=c(-0.2,0), legend=c("Conc.","PhiX (unmapped)", "PhiX (mapped)"), fill=c(4,5,6))
```

### Bases
```{r}
tmp <- getReadCounts("PhiX", mode="wcc")
phix.unmapped.bases <- tmp$unmapped
phix.mapped.bases <- tmp$mapped
```

```{r}
par(mar=c(15,6,2,8), xpd=TRUE)
barplot(rbind(trna.unmapped.bases,phix.unmapped.bases, phix.mapped.bases), beside=TRUE, las=2, main="tRNA filtered and PhiX bases", col=c(4,5,6))
legend("topright", inset=c(-0.2,0), legend=c("tRNA filtered","PhiX (unmapped)", "PhiX (mapped)"), fill=c(4,5,6))
```


# Alignments

## Bowtie

### Mature
First, we align the reads against the mature.fa file from mirbase.

```{r}
tmp <- getReadCounts("Mature", mode="wcl")
mature.unmapped.reads <- tmp$unmapped
mature.mapped.reads <- tmp$mapped
```

```{r}
par(mar=c(15,6,2,8), xpd=TRUE)
barplot(rbind(phix.unmapped.reads,mature.unmapped.reads, mature.mapped.reads), beside=TRUE, las=2, main="Filtered reads 
        aligned to Mature.fa", col=c(4,5,6))
legend("topright", inset=c(-0.2,0), legend=c("Total reads","Mature.fa (unmapped)", "Mature.fa (mapped)"), fill=c(4,5,6))
```

```{r}
tmp <- getReadCounts("Mature", mode="wcc")
mature.unmapped.bases <- tmp$unmapped
mature.mapped.bases <- tmp$mapped
```

```{r}
par(mar=c(15,6,2,8), xpd=TRUE)
barplot(rbind(phix.unmapped.bases, mature.unmapped.bases, mature.mapped.bases), beside=TRUE, las=2, main="Filtered bases aligned to Mature.fa", col=c(4,5,6))
legend("topright", inset=c(-0.2,0), legend=c("Total reads","Mature.fa (unmapped)", "Mature.fa (mapped)"), fill=c(4,5,6))
```


### Mature-species
Then, we align the miRNA against the mirbase species specific miRNA sequences only.

```{r}
tmp <- getReadCounts("Mature_Species", mode="wcl")
mature_species.unmapped.reads <- tmp$unmapped
mature_species.mapped.reads <- tmp$mapped
```

```{r}
par(mar=c(15,6,2,8), xpd=TRUE)
barplot(rbind(phix.unmapped.reads,mature_species.unmapped.reads, mature_species.mapped.reads), beside=TRUE, las=2, main="Filtered reads 
        aligned to Mature_Species.fa", col=c(4,5,6))
legend("topright", inset=c(-0.2,0), legend=c("Total reads","Mature_Species.fa (unmapped)", "Mature_Species.fa (mapped)"), fill=c(4,5,6))
```

```{r}
tmp <- getReadCounts("Mature_Species", mode="wcc")
mature_species.unmapped.bases <- tmp$unmapped
mature_species.mapped.bases <- tmp$mapped
```

```{r}
par(mar=c(15,6,2,8), xpd=TRUE)
barplot(rbind(phix.unmapped.bases, mature_species.unmapped.bases, mature_species.mapped.bases), beside=TRUE, las=2, main="Filtered bases aligned to Mature_Species.fa", col=c(4,5,6))
legend("topright", inset=c(-0.2,0), legend=c("Total reads","Mature_Species.fa (unmapped)", "Mature_Species.fa (mapped)"), fill=c(4,5,6))
```
Differences between the total Mature.fa and Mature_Species.fa only:

```{r}
par(mar=c(15,6,2,8), xpd=TRUE)
barplot(mature.mapped.reads - mature_species.mapped.reads, las=2, main="Reads that align more to Mature.fa vs Mature_Species.fa", col=c(4))
```


### Hairpin
Then, we align the reads that do not align to mature.fa against the hairpin.fa file from mirbase.

```{r}
tmp <- getReadCounts("Hairpin", mode="wcl")
hairpin.unmapped.reads <- tmp$unmapped
hairpin.mapped.reads <- tmp$mapped
```

```{r}
par(mar=c(15,6,2,8), xpd=TRUE)
barplot(rbind(mature.unmapped.reads, hairpin.unmapped.reads, hairpin.mapped.reads), beside=TRUE, las=2, main="Mature.fa unaligned reads aligned to Hairpin.fa", col=c(4,5,6))
legend("topright", inset=c(-0.2,0), legend=c("Mature.fa (unmapped)","Hairpin.fa (unmapped)", "Hairpin.fa (mapped)"), fill=c(4,5,6))
```

```{r}
tmp <- getReadCounts("Hairpin", mode="wcc")
hairpin.unmapped.bases <- tmp$unmapped
hairpin.mapped.bases <- tmp$mapped
```

```{r}
par(mar=c(15,6,2,8), xpd=TRUE)
barplot(rbind(mature.unmapped.bases, hairpin.unmapped.bases, hairpin.mapped.bases), beside=TRUE, las=2, main="Mature.fa unaligned bases aligned to Hairpin.fa", col=c(4,5,6))
legend("topright", inset=c(-0.2,0), legend=c("Mature.fa (unmapped)","Hairpin.fa (unmapped)", "Hairpin.fa (mapped)"), fill=c(4,5,6))
```

### Hairpin-species
Then, we align the miRNA against the mirbase species specific Hairpin sequences only.

```{r, eval=FALSE}
tmp <- getReadCounts("Hairpin_Species", mode="wcl")
hairpin_species.unmapped.reads <- tmp$unmapped
hairpin_species.mapped.reads <- tmp$mapped
```


### Reference
The remaining reads we align then against the reference genome

```{r}
if(bowtieRefAlignment){
  tmp <- getReadCounts("Reference", mode="wcl")
  reference.bowtie.unmapped.reads <- tmp$unmapped
  reference.bowtie.mapped.reads <- tmp$mapped
} else {
  reference.bowtie.unmapped.reads <- rep(0,length(samples))
  reference.bowtie.mapped.reads <-  rep(0,length(samples))
  }
```

```{r}
if(bowtieRefAlignment){
  useTitle <- "Hairpin.fa unaligned reads aligned to reference genome"
} else {
  useTitle <- "Bowtie alignment against Reference genome was not executed" 
}
par(mar=c(15,6,2,8), xpd=TRUE)
barplot(rbind(hairpin.unmapped.reads, reference.bowtie.unmapped.reads, reference.bowtie.mapped.reads), beside=TRUE, las=2, main=useTitle, col=c(4,5,6))
legend("topright", inset=c(-0.2,0), legend=c("Hairpin.fa (unmapped)","Reference (unmapped)", "Reference (mapped)"), fill=c(4,5,6))
```

```{r}
if(bowtieRefAlignment){
  tmp <- getReadCounts("Reference", mode="wcc")
  reference.bowtie.unmapped.bases <- tmp$unmapped
  reference.bowtie.mapped.bases <- tmp$mapped
} else {
  reference.bowtie.unmapped.bases <- rep(0,length(samples))
  reference.bowtie.mapped.bases <- rep(0,length(samples))
}
```

```{r}
if(bowtieRefAlignment){
  useTitle <- "Hairpin.fa unaligned bases aligned to reference genome"
} else {
  useTitle <- "Bowtie alignment against Reference genome was not executed" 
}
par(mar=c(15,6,2,8), xpd=TRUE)
barplot(rbind(hairpin.unmapped.bases, reference.bowtie.unmapped.bases, reference.bowtie.mapped.bases), beside=TRUE, las=2, main=useTitle, col=c(4,5,6))
legend("topright", inset=c(-0.2,0), legend=c("Hairpin.fa (unmapped)","Reference (unmapped)", "Reference (mapped)"), fill=c(4,5,6))
```


## STAR
We align the data also with STAR, due to its soft-clipping feature

### Mature
Analysis of the STAR alignment logs

```{r}
starlogs.dirs <- list.dirs(file.path(projFolder,"BAM", "STAR", "Mature"))[-1]

starlogs <- list()

for(i in 1:length(starlogs.dirs)){
starlogs[[i]] <- importSTARLog(starlogs.dirs[i])
}

starlogs.totalReads <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",2),"[",2),"[",1))
starlogs.inputReadLength <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",2),"[",2),"[",2))
starlogs.uniqueReads <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",3),"[",2),"[",1))
starlogs.uniqueReadsPercent <- as.numeric(gsub("%","",sapply(sapply(sapply(sapply(starlogs,"[",2),"[",3),"[",2),"[",2)))
starlogs.uniqueReadsLength <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",3),"[",2),"[",3))
starlogs.multiReads <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",4),"[",2),"[",1))
starlogs.multiReads.toomany <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",4),"[",2),"[",3))
starlogs.umappedReads.mismatch <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",5),"[",2),"[",1))
starlogs.umappedReads.tooShort <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",5),"[",2),"[",3))
starlogs.chimericReads <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",6),"[",2),"[",1))
```

```{r}
par(mar=c(5,6,2,12), xpd=TRUE)
starlogs.matrix <- rbind(starlogs.uniqueReads,
                         starlogs.multiReads,
                         starlogs.multiReads.toomany,
                         starlogs.umappedReads.mismatch,
                         starlogs.umappedReads.tooShort,
                         starlogs.chimericReads)
colnames(starlogs.matrix) <- gsub(paste0(file.path(projFolder,"BAM", "STAR", "Mature"),"/"),"",starlogs.dirs)

barplot(starlogs.matrix, col=2:7, main = "STAR alignment stats (Mature.fa)", las=2)
legend("topright", inset=c(-0.5,0), legend=gsub("starlogs.","",rownames(starlogs.matrix)), fill=c(2:7))
```

Unmapped 'Others' is currently not imported from the STAR-logs functions, hence some reads do not add up to 100% here, per sample this is:

```{r}
barplot(phix.unmapped.reads - apply(starlogs.matrix,2,sum), las=2, main="Unconsidered reads in above barplot")
```
### Mature-Species
Analysis of the STAR alignment logs

```{r}
starlogs.dirs <- list.dirs(file.path(projFolder,"BAM", "STAR", "Mature_Species"))[-1]

starlogs <- list()

for(i in 1:length(starlogs.dirs)){
starlogs[[i]] <- importSTARLog(starlogs.dirs[i])
}

starlogs.totalReads <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",2),"[",2),"[",1))
starlogs.inputReadLength <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",2),"[",2),"[",2))
starlogs.uniqueReads <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",3),"[",2),"[",1))
starlogs.uniqueReadsPercent <- as.numeric(gsub("%","",sapply(sapply(sapply(sapply(starlogs,"[",2),"[",3),"[",2),"[",2)))
starlogs.uniqueReadsLength <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",3),"[",2),"[",3))
starlogs.multiReads <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",4),"[",2),"[",1))
starlogs.multiReads.toomany <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",4),"[",2),"[",3))
starlogs.umappedReads.mismatch <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",5),"[",2),"[",1))
starlogs.umappedReads.tooShort <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",5),"[",2),"[",3))
starlogs.chimericReads <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",6),"[",2),"[",1))
```

```{r}
par(mar=c(5,6,2,12), xpd=TRUE)
starlogs.matrix <- rbind(starlogs.uniqueReads,
                         starlogs.multiReads,
                         starlogs.multiReads.toomany,
                         starlogs.umappedReads.mismatch,
                         starlogs.umappedReads.tooShort,
                         starlogs.chimericReads)
colnames(starlogs.matrix) <- gsub(paste0(file.path(projFolder,"BAM", "STAR", "Mature"),"/"),"",starlogs.dirs)

barplot(starlogs.matrix, col=2:7, main = "STAR alignment stats (Mature_species.fa)", las=2)
legend("topright", inset=c(-0.5,0), legend=gsub("starlogs.","",rownames(starlogs.matrix)), fill=c(2:7))
```

Unmapped 'Others' is currently not imported from the STAR-logs functions, hence some reads do not add up to 100% here, per sample this is:

```{r}
barplot(phix.unmapped.reads - apply(starlogs.matrix,2,sum), las=2, main="Unconsidered reads in above barplot")
```


### Reference
Analysis of the STAR alignment logs

```{r}
starlogs.dirs <- list.dirs(file.path(projFolder,"BAM", "STAR", "Reference"))[-1]

starlogs <- list()

for(i in 1:length(starlogs.dirs)){
starlogs[[i]] <- importSTARLog(starlogs.dirs[i])
}

starlogs.totalReads <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",2),"[",2),"[",1))
starlogs.inputReadLength <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",2),"[",2),"[",2))
starlogs.uniqueReads <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",3),"[",2),"[",1))
starlogs.uniqueReadsPercent <- as.numeric(gsub("%","",sapply(sapply(sapply(sapply(starlogs,"[",2),"[",3),"[",2),"[",2)))
starlogs.uniqueReadsLength <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",3),"[",2),"[",3))
starlogs.multiReads <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",4),"[",2),"[",1))
starlogs.multiReads.toomany <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",4),"[",2),"[",3))
starlogs.umappedReads.mismatch <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",5),"[",2),"[",1))
starlogs.umappedReads.tooShort <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",5),"[",2),"[",3))
starlogs.chimericReads <- as.numeric(sapply(sapply(sapply(sapply(starlogs,"[",2),"[",6),"[",2),"[",1))
```

```{r}
par(mar=c(5,6,2,12), xpd=TRUE)
starlogs.matrix <- rbind(starlogs.uniqueReads,
                         starlogs.multiReads,
                         starlogs.multiReads.toomany,
                         starlogs.umappedReads.mismatch,
                         starlogs.umappedReads.tooShort,
                         starlogs.chimericReads)
colnames(starlogs.matrix) <- gsub(paste0(file.path(projFolder,"BAM", "STAR", "Reference"),"/"),"",starlogs.dirs)

barplot(starlogs.matrix, col=2:7, main = "STAR alignment stats (Reference)", las=2)
legend("topright", inset=c(-0.5,0), legend=gsub("starlogs.","",rownames(starlogs.matrix)), fill=c(2:7))
```

Unmapped 'Others' is currently not imported from the STAR-logs functions, hence some reads do not add up to 100% here, per sample this is:

Actually, I use here the starlog.totalReads and not the hairpin_species. THIS NEEDS TO BE ADJUSTED!!!
```{r}
barplot(starlogs.totalReads - apply(starlogs.matrix,2,sum), las=2, main="Unconsidered reads in above barplot")
```

ADD STILL STATISTICS ON THE SOFT-CLIPPING, HOW MUCH IS CLIPPED, CAN WE ALIGN THE SOFT-CLIPPED AGAIN, HOW FAR ARE THE ALIGNED SOFT-CLIPPED PARTS AWAY FROM THEIR 'PARTNER'?

# Quantification

## Mirbase - Mature.fa

### Bowtie

### STAR

```{r}
star.mature.files <- list.files(file.path(projFolder,"QUANTIFICATION", "STAR","Mirbase"), pattern="*mature.txt")

star.mature <- read.table(file.path(projFolder,"QUANTIFICATION", "STAR","Mirbase", star.mature.files[1]), skip=1)
colnames(star.mature) <- c(star.mature.files[1], "miRNA")

for(i in 2:length(star.mature.files)){
    tmp.star.mature <- read.table(file.path(projFolder,"QUANTIFICATION", "STAR","Mirbase", star.mature.files[i]), skip=1)
    colnames(tmp.star.mature) <- c(star.mature.files[i], "miRNA")
    
    star.mature <- merge(star.mature, tmp.star.mature, by="miRNA")
}

star.mature[is.na(star.mature)] <- 0

#scale.factors <- calcNormFactors(star.mature[,-1],lib.size=conc.reads, method = "TMM")
#star.mature.tmm <- t(t(star.mature[,-1])/(scale.factors*conc.reads))

```

```{r}
barplot(apply(star.mature[,-1],2,sum), las=2, main="Reads aligned to Mature.fa")
```
RPKM quantification of mirbase mature.fa miRNAs.

```{r}
# Get the quantification
mirbase_mature_quant.files <- list.files(file.path(projFolder, "QUANTIFICATION", "STAR", "Mirbase"), pattern="*mature.txt")
mirbase_mature_quant <- read.table(file.path(projFolder, "QUANTIFICATION", "STAR", "Mirbase", mirbase_mature_quant.files[1]), skip=1)
colnames(mirbase_mature_quant) <- c(gsub("_star_mature.txt", "", mirbase_mature_quant.files[1]), "miRNA")
for(i in 2:length(mirbase_mature_quant.files)){
  tmp <- read.table(file.path(projFolder, "QUANTIFICATION", "STAR", "Mirbase", mirbase_mature_quant.files[i]), skip=1)
  colnames(tmp) <- c(gsub("_star_mature.txt", "", mirbase_mature_quant.files[i]), "miRNA")
  mirbase_mature_quant <- merge(mirbase_mature_quant, tmp, by="miRNA")
}
mirbase_mature_quant.miomapped <- apply(mirbase_mature_quant[,-1],2,sum)/1000000
mirbase_mature_quant.rpkm <- t(t(mirbase_mature_quant[,-1])/mirbase_mature_quant.miomapped)
rownames(mirbase_mature_quant.rpkm) <- mirbase_mature_quant[,1]

datatable(mirbase_mature_quant.rpkm)
```

## Mirbase - Mature_Species.fa

### Bowtie

### STAR

```{r}
star.mature_species.files <- list.files(file.path(projFolder,"QUANTIFICATION", "STAR","Mirbase"), pattern="*mature_species.txt")

star.mature_species <- read.table(file.path(projFolder,"QUANTIFICATION", "STAR","Mirbase", star.mature_species.files[1]), skip=1)
colnames(star.mature_species) <- c(star.mature_species.files[1], "miRNA")

for(i in 2:length(star.mature_species.files)){
    tmp.star.mature_species <- read.table(file.path(projFolder,"QUANTIFICATION", "STAR","Mirbase", star.mature_species.files[i]), skip=1)
    colnames(tmp.star.mature_species) <- c(star.mature_species.files[i], "miRNA")
    
    star.mature_species <- merge(star.mature_species, tmp.star.mature_species, by="miRNA", all=TRUE)
}
star.mature_species[is.na(star.mature_species)] <- 0

#scale.factors <- calcNormFactors(star.mature_species[,-1],lib.size=conc.reads, method = "TMM")
#star.mature_species.tmm <- t(t(star.mature_species[,-1])/(scale.factors*conc.reads))

mirbase.mature_species.miomapped <- apply(star.mature_species[,-1],2,sum)/1000000

star.mature_species.rpkm <- t(t(star.mature_species[,-1])/mirbase.mature_species.miomapped)
rownames(star.mature_species.rpkm) <- star.mature_species[,1]
```


```{r}
barplot(apply(star.mature_species[,-1], 2, sum), las=2, main="Reads aligned to Mature_Species.fa")
```
The raw counts per mature mirna per sample
```{r}
# Get the quantification
mirbase_mature_species_quant.files <- list.files(file.path(projFolder, "QUANTIFICATION", "STAR", "Mirbase"), pattern="*mature_species.txt")
mirbase_mature_species_quant <- read.table(file.path(projFolder, "QUANTIFICATION", "STAR", "Mirbase", mirbase_mature_species_quant.files[1]), skip=1)
colnames(mirbase_mature_species_quant) <- c(gsub("_star_mature_species.txt", "", mirbase_mature_species_quant.files[1]), "miRNA")
for(i in 2:length(mirbase_mature_species_quant.files)){
  tmp <- read.table(file.path(projFolder, "QUANTIFICATION", "STAR", "Mirbase", mirbase_mature_species_quant.files[i]), skip=1)
  colnames(tmp) <- c(gsub("_star_mature_species.txt", "", mirbase_mature_species_quant.files[i]), "miRNA")
  mirbase_mature_species_quant <- merge(mirbase_mature_species_quant, tmp, by="miRNA")
}
mirbase_mature_species_quant.miomapped <- apply(mirbase_mature_species_quant[,-1],2,sum)/1000000
mirbase_mature_species_quant.rpkm <- t(t(mirbase_mature_species_quant[,-1])/mirbase_mature_species_quant.miomapped)
rownames(mirbase_mature_species_quant.rpkm) <- mirbase_mature_species_quant[,1]

datatable(mirbase_mature_species_quant)
```

And the RPKM normalised values

```{r}
datatable(mirbase_mature_species_quant.rpkm)
```

## Mirbase - Hairpin.fa

### Bowtie

### STAR

```{r}
star.hairpin.files <- list.files(file.path(projFolder,"QUANTIFICATION", "STAR","Mirbase"), pattern="*hairpin.txt")

star.hairpin <- read.table(file.path(projFolder,"QUANTIFICATION", "STAR","Mirbase", star.hairpin.files[1]), skip=1)
colnames(star.hairpin) <- c(star.hairpin.files[1], "miRNA")

for(i in 2:length(star.hairpin.files)){
    tmp.star.hairpin <- read.table(file.path(projFolder,"QUANTIFICATION", "STAR","Mirbase", star.hairpin.files[i]), skip=1)
    colnames(tmp.star.hairpin) <- c(star.hairpin.files[i], "miRNA")
    
    star.hairpin <- merge(star.hairpin, tmp.star.hairpin, by="miRNA")
}

star.hairpin[is.na(star.hairpin)] <- 0

#scale.factors <- calcNormFactors(star.hairpin[,-1],lib.size=conc.reads, method = "TMM")
#star.hairpin.tmm <- t(t(star.hairpin[,-1])/(scale.factors*conc.reads))

```

```{r}
barplot(apply(star.hairpin[,-1],2,sum), las=2, main="Reads aligned to Hairpin.fa")
```

```{r}
# Get the quantification
mirbase_hairpin_quant.files <- list.files(file.path(projFolder, "QUANTIFICATION", "STAR", "Mirbase"), pattern="*hairpin.txt")
mirbase_hairpin_quant <- read.table(file.path(projFolder, "QUANTIFICATION", "STAR", "Mirbase", mirbase_hairpin_quant.files[1]), skip=1)
colnames(mirbase_hairpin_quant) <- c(gsub("_star_hairpin.txt", "", mirbase_hairpin_quant.files[1]), "miRNA")
for(i in 2:length(mirbase_hairpin_quant.files)){
  tmp <- read.table(file.path(projFolder, "QUANTIFICATION", "STAR", "Mirbase", mirbase_hairpin_quant.files[i]), skip=1)
  colnames(tmp) <- c(gsub("_star_hairpin.txt", "", mirbase_hairpin_quant.files[i]), "miRNA")
  mirbase_hairpin_quant <- merge(mirbase_hairpin_quant, tmp, by="miRNA")
}
mirbase_hairpin_quant.miomapped <- apply(mirbase_hairpin_quant[,-1],2,sum)/1000000
mirbase_hairpin_quant.rpkm <- t(t(mirbase_hairpin_quant[,-1])/mirbase_hairpin_quant.miomapped)
rownames(mirbase_hairpin_quant.rpkm) <- mirbase_hairpin_quant[,1]

datatable(mirbase_hairpin_quant.rpkm)
```

## Mirbase - Hairpin_Species.fa

### Bowtie

### STAR
```{r}
star.hairpin_species.files <- list.files(file.path(projFolder,"QUANTIFICATION", "STAR","Mirbase"), pattern="*hairpin_species.txt")

star.hairpin_species <- read.table(file.path(projFolder,"QUANTIFICATION", "STAR","Mirbase", star.hairpin_species.files[1]), skip=1)
colnames(star.hairpin_species) <- c(star.hairpin_species.files[1], "miRNA")

for(i in 2:length(star.hairpin_species.files)){
    tmp.star.hairpin_species <- read.table(file.path(projFolder,"QUANTIFICATION", "STAR","Mirbase", star.hairpin_species.files[i]), skip=1)
    colnames(tmp.star.hairpin_species) <- c(star.hairpin_species.files[i], "miRNA")
    
    star.hairpin_species <- merge(star.hairpin_species, tmp.star.hairpin_species, by="miRNA", all=TRUE)
}
star.hairpin_species[is.na(star.hairpin_species)] <- 0

#scale.factors <- calcNormFactors(star.hairpin_species[,-1],lib.size=conc.reads, method = "TMM")
#star.hairpin_species.tmm <- t(t(star.hairpin_species[,-1])/(scale.factors*conc.reads))
```


```{r}
barplot(apply(star.hairpin_species[,-1], 2, sum), las=2, main="Reads aligned to Hairpin_Species.fa")
```
```{r}
# Get the quantification
mirbase_hairpin_species_quant.files <- list.files(file.path(projFolder, "QUANTIFICATION", "STAR", "Mirbase"), pattern="*hairpin_species.txt")
mirbase_hairpin_species_quant <- read.table(file.path(projFolder, "QUANTIFICATION", "STAR", "Mirbase", mirbase_hairpin_species_quant.files[1]), skip=1)
colnames(mirbase_hairpin_species_quant) <- c(gsub("_star_hairpin_species.txt", "", mirbase_hairpin_species_quant.files[1]), "miRNA")
for(i in 2:length(mirbase_hairpin_species_quant.files)){
  tmp <- read.table(file.path(projFolder, "QUANTIFICATION", "STAR", "Mirbase", mirbase_hairpin_species_quant.files[i]), skip=1)
  colnames(tmp) <- c(gsub("_star_hairpin_species.txt", "", mirbase_hairpin_species_quant.files[i]), "miRNA")
  mirbase_hairpin_species_quant <- merge(mirbase_hairpin_species_quant, tmp, by="miRNA")
}
mirbase_hairpin_species_quant.miomapped <- apply(mirbase_hairpin_species_quant[,-1],2,sum)/1000000
mirbase_hairpin_species_quant.rpkm <- t(t(mirbase_hairpin_species_quant[,-1])/mirbase_hairpin_species_quant.miomapped)
rownames(mirbase_hairpin_species_quant.rpkm) <- mirbase_hairpin_species_quant[,1]

datatable(mirbase_hairpin_species_quant)
datatable(mirbase_hairpin_species_quant.rpkm)
```

### Differences Mature.fa and Mature_Species.fa

## Reference
First some general stats about the used reference genome annotation

```{r}
annotation <- importGTF(refAnnot.file)
```

Following numbers of various annotations per biotype are available inside annotaiton file

```{r}
out_html <- knitr::kable(table(annotation$gene_biotype), col.names = NULL, "html")
kable_styling(out_html, "striped", position = "left")
``` 

### Bowtie
```{r}
if(bowtieRefAlignment){
  fc.files <- list.files(file.path(projFolder, "QUANTIFICATION", "BOWTIE", "Reference"), pattern="*.txt$")
  fc.in <- list()
  for(i in 1:length(fc.files)){
    fc.in[[i]] <- importFeatureCounts(file.path(projFolder, "QUANTIFICATION", "BOWTIE", "Reference", fc.files[i]))
  }
  
  fc.expr.bowtie <- merge(fc.in[[1]]$expValues, fc.in[[2]]$expValues, by="Geneid")
  
  for(i in 3:length(fc.files)){
    fc.expr.bowtie <- merge(fc.expr.bowtie, fc.in[[i]]$expValues, by="Geneid")
  }
  colnames(fc.expr.bowtie) <- sub(".*?Reference.", "",colnames(fc.expr.bowtie))
  colnames(fc.expr.bowtie) <- sub("_reference_star.bam", "",colnames(fc.expr.bowtie))
}
```

Now get the counts per biotype

```{r}
if(bowtieRefAlignment){
  biotypes <- names(table(annotation$gene_biotype))
  
  counts_per_biotype.bowtie <- matrix(0, ncol=ncol(fc.expr.bowtie)-1, nrow=length(biotypes))
  rownames(counts_per_biotype.bowtie) <- biotypes
  colnames(counts_per_biotype.bowtie) <- colnames(fc.expr.bowtie)[-1]
  
  for(i in 1:length(biotypes)){
    biotype.genes <- annotation$gene_id[annotation$gene_biotype==biotypes[i]]
    counts_per_biotype.bowtie[i,] <- apply(fc.expr.bowtie[is.element(fc.expr.bowtie$Geneid, biotype.genes),-1],2,sum)
  }
}
```

```{r}
if(bowtieRefAlignment){
  out_html <- knitr::kable(counts_per_biotype.bowtie, "html")
  kable_styling(out_html, "striped", position = "left")
}
```

```{r}
if(bowtieRefAlignment){
  out_html <- knitr::kable(round(t(t(counts_per_biotype.bowtie)/apply(counts_per_biotype.bowtie,2,sum))*100,2), "html")
  kable_styling(out_html, "striped", position = "left")
}
```


### STAR
The quantification of the multimapping reads is as follows. With featureCounts, we only count the primary alignment, all secondary alignments we ignore. However, while aligning the data, we assign the primary alignment for multi-mapped reads randomly!!!

```{r}
fc.files <- list.files(file.path(projFolder, "QUANTIFICATION", "STAR", "Reference"), pattern="*reference_fc.txt$")
fc.in <- list()
for(i in 1:length(fc.files)){
  fc.in[[i]] <- importFeatureCounts(file.path(projFolder, "QUANTIFICATION", "STAR", "Reference", fc.files[i]))
}

fc.expr.star <- merge(fc.in[[1]]$expValues, fc.in[[2]]$expValues, by="Geneid")

for(i in 3:length(fc.files)){
  fc.expr.star <- merge(fc.expr.star, fc.in[[i]]$expValues, by="Geneid")
}
colnames(fc.expr.star) <- sub(".*?Reference.", "",colnames(fc.expr.star))
colnames(fc.expr.star) <- sub("_reference_star.bam", "",colnames(fc.expr.star))

#scale.factors <- calcNormFactors(fc.expr.star[,-1],lib.size=conc.reads, method = "TMM")
#fc.expr.star.tmm <- t(t(fc.expr.star[,-1])/(scale.factors*conc.reads))
#rownames(fc.expr.star.tmm) <- fc.expr.star[,1]

# Do the RPKM normalisation
alignmentStats <- mapply(cbind,sapply((sapply(fc.in,"[",3)),"[",2))
alignmentStats <- alignmentStats[,-2]
star.reads.mapped <- apply(alignmentStats,2,sum)
tmp <- fc.expr.star
tmp <- merge(tmp, annotation, by.x="Geneid", by.y="gene_id")
gene.length <- abs(tmp$V5 - tmp$V4)/1000
mio.reads.mapped <- star.reads.mapped/1000000

fc.expr.star.rpkm <- tmp[,2:(length(mio.reads.mapped)+1)]
fc.expr.star.rpkm <- t(t(fc.expr.star.rpkm)/gene.length)
fc.expr.star.rpkm <- t(t(fc.expr.star.rpkm)/mio.reads.mapped)
rownames(fc.expr.star.rpkm) <- tmp[,1]
```

```{r}
# Lets extract the featureCounts statistics

fc.expr.stats <- merge(fc.in[[1]]$summary, fc.in[[2]]$summary, by="Status")

for(i in 3:length(fc.files)){
  fc.expr.stats <- merge(fc.expr.stats, fc.in[[i]]$summary, by="Status")
}
```

Now get the counts per biotype

```{r, results="asis"}
biotypes <- names(table(annotation$gene_biotype))

counts_per_biotype <- matrix(0, ncol=ncol(fc.expr.star)-1, nrow=length(biotypes))
rownames(counts_per_biotype) <- biotypes
colnames(counts_per_biotype) <- colnames(fc.expr.star)[-1]

dir.create(file.path(projFolder, "RESULTS"), showWarnings=FALSE)
dir.create(file.path(projFolder, "RESULTS", "Biotype-expressions"), showWarnings=FALSE)

star.protein_coding.rpkm <- NULL

for(i in 1:length(biotypes)){
  biotype.genes <- annotation$gene_id[annotation$gene_biotype==biotypes[i]]
  tmp <- fc.expr.star[is.element(fc.expr.star$Geneid, biotype.genes),]
  if(length(biotype.genes)==1){
    tmp.rpkm <- t(as.matrix(fc.expr.star.rpkm[is.element(rownames(fc.expr.star.rpkm), biotype.genes),]))
    rownames(tmp.rpkm) <- biotype.genes
  } else {
     tmp.rpkm <- fc.expr.star.rpkm[is.element(rownames(fc.expr.star.rpkm), biotype.genes),]
  }
  
  if(biotypes[i]=="protein_coding"){
    star.protein_coding.rpkm <- fc.expr.star.rpkm[is.element(rownames(fc.expr.star.rpkm), biotype.genes),]
  }
  
  rownames(tmp) <- tmp[,1]
  tmp <- tmp[,-1]
  tmp.expression <- sort(apply(tmp,1,sum), decreasing = TRUE)
  tmp.rpkm.expression <- sort(apply(tmp.rpkm,1,sum), decreasing = TRUE)
  
  
  if(sum(tmp.rpkm.expression)>0){
    png(file.path(projFolder,"RESULTS", "Biotype-expressions", paste0("Expression_histogram_", biotypes[i],".png")), width=1000, height=800)
      boxplot(log(tmp.rpkm.expression), main=paste("Biotype", biotypes[i]))
    dev.off()
  }
  toplist <- data.frame(gene_id=names(tmp.expression),
                        total.expression.rpkm=tmp.rpkm.expression,
                        avg.expression.rpkm=tmp.rpkm.expression/ncol(tmp))
  
  report_toplist <- merge(annotation, toplist, by="gene_id")
  report_toplist <- report_toplist[order(report_toplist$avg.expression, decreasing = TRUE),]

  write.table(report_toplist, file.path(projFolder,"RESULTS", "Biotype-expressions", paste0("top20_expressed-", biotypes[i],".csv")), col.names = TRUE, row.names = FALSE, quote=FALSE, sep="\t")
  
  #out_html <- knitr::kable(report_toplist, "html")
  #print(kable_styling(out_html, "striped", position = "left"))
   
  cat("### ", biotypes[i], "\n")
  print(htmltools::tagList(datatable(report_toplist)))
   
  counts_per_biotype[i,] <- apply(fc.expr.star[is.element(fc.expr.star$Geneid, biotype.genes),-1],2,sum)
}

counts_per_biotype <- rbind(apply(star.hairpin_species[,-1],2,sum), 
                            apply(star.mature_species[,-1],2,sum),
                            counts_per_biotype)

rownames(counts_per_biotype)[1:2] <- c("Mirbase_hairpin_species", "Mirbase_mirna_species")

# Now write out still the mirbase stats:
## hairpin_species
  tmp.expression <- apply(star.hairpin_species[,-1],1,sum)
  names(tmp.expression) <- star.hairpin_species[,1]
  png(file.path(projFolder,"RESULTS", "Biotype-expressions", paste0("Expression_histogram_Mirbase_hairpin_species.png")), width=1000, height=800)
    boxplot(log(tmp.expression), main=paste("Biotype", biotypes[i]))
  dev.off()
  tmp <- sort(tmp.expression, decreasing=TRUE)[1:20]
  report_toplist <- data.frame(hairpin = names(tmp),
                               avg.expression = tmp/(ncol(star.hairpin_species)-1))
  report_toplist <- report_toplist[order(report_toplist$avg.expression, decreasing = TRUE),]
  write.table(report_toplist, file.path(projFolder,"RESULTS", "Biotype-expressions", paste0("top20_expressed-Mirbase_hairpin_species.csv")), col.names = TRUE, row.names = FALSE, quote=FALSE, sep="\t")
  cat("### Hairpin_Species.fa \n")
  print(htmltools::tagList(datatable(report_toplist)))
  
## mature_species
  tmp.expression <- apply(star.mature_species[,-1],1,sum)
  names(tmp.expression) <- star.mature_species[,1]
  png(file.path(projFolder,"RESULTS", "Biotype-expressions", paste0("Expression_histogram_Mirbase_mature_species.png")), width=1000, height=800)
    boxplot(log(tmp.expression), main=paste("Biotype", biotypes[i]))
  dev.off()
  tmp <- sort(tmp.expression, decreasing=TRUE)[1:20]
  report_toplist <- data.frame(mature = names(tmp),
                               avg.expression = tmp/(ncol(star.mature_species)-1))
  report_toplist <- report_toplist[order(report_toplist$avg.expression, decreasing = TRUE),]
  write.table(report_toplist, file.path(projFolder,"RESULTS", "Biotype-expressions", paste0("top20_expressed-Mirbase_mature_species.csv")), col.names = TRUE, row.names = FALSE, quote=FALSE, sep="\t")
  cat("### Mature_species.fa \n")
  print(htmltools::tagList(datatable(report_toplist)))
  
```

```{r}
out_html <- knitr::kable(counts_per_biotype, "html")
kable_styling(out_html, "striped", position = "left")
```

Percentages with reference to assigned (NOT! aligned) reads

```{r}
out_html <- knitr::kable(round(t(t(counts_per_biotype)/apply(counts_per_biotype,2,sum))*100,2), "html")
kable_styling(out_html, "striped", position = "left")
```

Percentages with reference to total number of qc-passed reads:

```{r}
out_html <- knitr::kable(round(t(t(counts_per_biotype)/conc.reads)*100,2), "html")
kable_styling(out_html, "striped", position = "left")
```

## Novel genes/miRNA

```{r}
# Import the novel miRNA annotation
novelMirna <- importBed(file.path(projFolder, "Reference", "novelLoci.bed"))
```

```{r}
novelMirna.summary <- summary(novelMirna[,3] - novelMirna[,2])
out <- data.frame(c("Number of novel predicted miRNA",
                    "Minimum length",
                    "1st quartile length",
                    "Median length",
                    "Mean length",
                    "3rd quartile length",
                    "Max length"),
                  c(nrow(novelMirna),
                    novelMirna.summary[1],
                    novelMirna.summary[2],
                    novelMirna.summary[3],
                    novelMirna.summary[4],
                    novelMirna.summary[5],
                    novelMirna.summary[6]))

rownames(out) <- NULL

out_html <- knitr::kable(out, col.names = NULL, "html")
kable_styling(out_html, "striped", position = "left")
```

```{r}
# Import the quantification
novel.quant <- read.table(file.path(file.path(projFolder, "QUANTIFICATION", "STAR", "Novel_genes", paste0(samples[1],"_star_novelMirna_bedtools.txt"))))
colnames(novel.quant) <- c("Chr", "Start", "End", "Name", samples[1])

for(i in 2:length(samples)){
  tmp <- read.table(file.path(file.path(projFolder, "QUANTIFICATION", "STAR", "Novel_genes", paste0(samples[i],"_star_novelMirna_bedtools.txt"))))
  colnames(tmp) <- c("Chr", "Start", "End", "Name", samples[i])
  novel.quant <- merge(novel.quant, tmp[,c("Name", samples[i])], by="Name")
}

novel.rpkm <- as.matrix(novel.quant[,-c(1:4)])
rownames(novel.rpkm) <- novel.quant$Name

novel.miomapped <- apply(novel.rpkm,2,sum)/10^6
novel.kb <- as.numeric(gsub("bp","",sapply(strsplit(rownames(novel.rpkm),"_"),"[",2)))/1000

novel.rpkm.kb <- novel.rpkm/novel.kb

novel.rpkm <- t(t(novel.rpkm.kb)/novel.miomapped)

```

### Visualisation of novel loci

An overall visualisation, how the novel loci are distributed across the provided genome

```{r}
chr.sort <- function(x){
  x.num <- suppressWarnings(as.numeric(x[which(!is.na(as.numeric(x)))]))
  x.non_num <- suppressWarnings(x[which(is.na(as.numeric(x)))])
  c(sort(x.num), sort(x.non_num))
}

genome.info <- read.table(paste0(refGenome.fullPath,".fai"))

chrs <- chr.sort(genome.info[,1])
chrs.length <- vector(mode="numeric", length=length(chrs))
names(chrs.length) <- chrs

index <- 1
for(i in chrs){
  chrs.length[index] <- genome.info$V2[genome.info==i]
  index <- index + 1
}
chrs.length <- chrs.length / 10^6
plot(NA, xlim=c(0,max(ceiling(chrs.length))), ylim=c(0,length(chrs)+1), xlab="Position (in Mb)", ylab="Chromosome", yaxt="n", main="Location on Chr of novel loci")

axis(2, at=1:length(chrs), chrs, las=2)

for(i in 1:length(chrs)){
  lines(c(0, chrs.length[i]), c(i,i))
}

for(i in 1:nrow(novelMirna)){
  jitter <- 0.1
  curChr <- which(novelMirna[i,1]==chrs)
  points(novelMirna[i,2]/10^6, curChr+jitter, pch = 16, cex = .6)
}



novelMirna.high <- novelMirna[which((apply(novel.quant[,-(1:4)],1,median))>1000),]

for(i in 1:nrow(novelMirna.high)){
  jitter <- 0.1
  curChr <- which(novelMirna.high[i,1]==chrs)
  points(novelMirna.high[i,2]/10^6, curChr+jitter, pch = 16, cex = .6, col="red")
}


```

### Expression table

```{r}
 datatable(novel.quant)
```



# Overall statistic

How are the reads distributed across contaminations, biotypes and features.

## Top-expressed per biotype and sample

The visualisation of the biotypes

```{r}
  use.color <- grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = TRUE)]
  set.seed(123)

  biotype_color_matrix <- data.frame(biotype=rownames(counts_per_biotype),
                                     color = sample(use.color, nrow(counts_per_biotype)))
  
  plot_counts_per_biotype <- as.data.frame(counts_per_biotype)
  plot_counts_per_biotype$biotype <- rownames(plot_counts_per_biotype)
  
  plot_counts_per_biotype <- merge(biotype_color_matrix, plot_counts_per_biotype , by="biotype")

  par(mfrow=c(1,2))

  barplot(as.matrix(plot_counts_per_biotype[,-c(1:2)]), col=plot_counts_per_biotype$color, las=2)

  
  plot.new()

  tmp <- apply(plot_counts_per_biotype[,-c(1:2)],1,sum)
  
  topBiotypes <- plot_counts_per_biotype[order(tmp, decreasing=TRUE),1:2]
  topBiotypes <- topBiotypes[1:10,1:2]

  legend.label <- plot_counts_per_biotype[is.element(plot_counts_per_biotype[,1], topBiotypes[,1]),1]
  legend.color <- plot_counts_per_biotype[is.element(plot_counts_per_biotype[,1], topBiotypes[,1]),2]
  
  legend("topleft",bty='n', xpd=NA, inset=c(0,-0.1),
       rev(legend.label), lty=1, cex=0.5, col=rev(legend.color), lwd=4)
  
# And now as percent
  par(mfrow=c(1,2))

  plotThis <- t(t(as.matrix(plot_counts_per_biotype[,-c(1:2)]))/apply(plot_counts_per_biotype[,-c(1:2)],2,sum))
  
  barplot(plotThis, col=plot_counts_per_biotype$color, las=2)

  
  plot.new()

  tmp <- apply(plot_counts_per_biotype[,-c(1:2)],1,sum)
  
  topBiotypes <- plot_counts_per_biotype[order(tmp, decreasing=TRUE),1:2]
  topBiotypes <- topBiotypes[1:10,1:2]

  legend.label <- plot_counts_per_biotype[is.element(plot_counts_per_biotype[,1], topBiotypes[,1]),1]
  legend.color <- plot_counts_per_biotype[is.element(plot_counts_per_biotype[,1], topBiotypes[,1]),2]
  
  legend("topleft",bty='n', xpd=NA, inset=c(0,0),
       rev(legend.label), lty=1, cex=0.5, col=rev(legend.color), lwd=4)
```


```{r}
samples.adj <- gsub("-",".", samples)

rawReads_perSample <- c()
for(i in 1:length(samples)){
  rawReads_perSample[i] <- sum(raw.reads[grep(samples[i], names(raw.reads))])
}
names(rawReads_perSample) <- samples

qcRemovedReads_perSample <- c()
for(i in 1:length(samples)){
  qcRemovedReads_perSample[i] <- rawReads_perSample[grep(samples[i], names(rawReads_perSample))]-sum(trimmed.reads[grep(samples[i], names(trimmed.reads))])
}

refAssignedReads_perSample <- c() 
for(i in 1:length(samples)){
  refAssignedReads_perSample[i] <- fc.expr.stats[1,grep(samples.adj[1], colnames(fc.expr.stats))]
}

refUnassigned_AmbiguityReads_perSample <- c() 
for(i in 1:length(samples)){
  refUnassigned_AmbiguityReads_perSample[i] <- fc.expr.stats[2,grep(samples.adj[i], colnames(fc.expr.stats))]
}

refUnassigned_NoFeatureReads_perSample <- c() 
for(i in 1:length(samples)){
  refUnassigned_NoFeatureReads_perSample[i] <- fc.expr.stats[8,grep(samples.adj[i], colnames(fc.expr.stats))]
}

refUnassigned_UnmappedReads_perSample <- c() 
for(i in 1:length(samples)){
  refUnassigned_UnmappedReads_perSample[i] <- fc.expr.stats[14,grep(samples.adj[i], colnames(fc.expr.stats))]
}

mirbaseAssigned_MatureReads_perSample <- c()
for(i in 1:length(samples)){
  mirbaseAssigned_MatureReads_perSample[i] <- sum(star.mature_species[,grep(samples[i], colnames(star.mature_species))])
}

mirbaseAssigned_HairpinReads_perSample <- c()
for(i in 1:length(samples)){
  mirbaseAssigned_HairpinReads_perSample[i] <- sum(star.hairpin_species[,grep(samples[i], colnames(star.hairpin_species))])
}

contamination_trnaReads_perSample <- c()
for(i in 1:length(samples)){
  contamination_trnaReads_perSample[i] <- trna.mapped.reads[grep(samples[i], names(trna.mapped.reads))]
}

contamination_phixReads_perSample <- c()
for(i in 1:length(samples)){
  contamination_phixReads_perSample[i] <- phix.mapped.reads[grep(samples[i], names(phix.mapped.reads))]
}

reference_CountsPerBiotype_perSample <- counts_per_biotype[-c(1:2),]

for(i in 1:length(samples)){
  reference_CountsPerBiotype_perSample[,i] <- counts_per_biotype[-c(1:2),grep(samples[i], colnames(counts_per_biotype))]
}


overall_stats <- rbind(qcRemovedReads_perSample,
                       contamination_trnaReads_perSample,
                       contamination_phixReads_perSample,
                       mirbaseAssigned_MatureReads_perSample,
                       mirbaseAssigned_HairpinReads_perSample,
                       refUnassigned_AmbiguityReads_perSample,
                       refUnassigned_NoFeatureReads_perSample,
                       reference_CountsPerBiotype_perSample,
                       refUnassigned_UnmappedReads_perSample
                       )

colnames(overall_stats) <- samples

#for(i in 1:length(samples)) unconsideredReads[i] <- conc.reads[i] - sum(fc.expr.stats[-12,(i+1)]) - sum(star.hairpin_species[,(i+1)]) - sum(star.mature_species[,(i+1)]) - trna.mapped.reads[i] - phix.mapped.reads[i]
```

## Origin of reads

### Absolute numbers

```{r}
  out_html <- knitr::kable(overall_stats, "html")
  kable_styling(out_html, "striped", position = "left")
```
  
```{r}
set.seed(123)
colors <- grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]

colorCode <- data.frame(class=rownames(overall_stats),
                         sample(colors, nrow(overall_stats)))
revVec <- function(x) x[(length(x):1)]
par(mar=c(15,5,2,22), xpd=TRUE)
barplot(overall_stats, col = colorCode[,2], las=2)
# Take the tenth largest value and only use biotypes that belong to this group and more reads
threshold <- sort(apply(overall_stats,1,sum),decreasing = TRUE)[10]
colorCodeSmall <- colorCode[apply(overall_stats,1,sum)>=threshold,]
legend("topright", inset=c(-1.4,0), legend=revVec(colorCodeSmall[,1]), fill=revVec(colorCodeSmall[,2]))
```
  
### Percentages

```{r}
  out_html <- knitr::kable(round(t(t(overall_stats)/apply(overall_stats,2,sum))*100,2) , "html")
  kable_styling(out_html, "striped", position = "left")
```

```{r}
set.seed(123)
colors <- grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]

colorCode <- data.frame(class=rownames(overall_stats),
                         sample(colors, nrow(overall_stats)))
revVec <- function(x) x[(length(x):1)]
par(mar=c(15,5,2,22), xpd=TRUE)

barplot(t(t(overall_stats)/apply(overall_stats,2,sum)), col = colorCode[,2], las=2)
# Take the tenth largest value and only use biotypes that belong to this group and more reads
threshold <- sort(apply(overall_stats,1,sum),decreasing = TRUE)[10]
colorCodeSmall <- colorCode[apply(overall_stats,1,sum)>=threshold,]
legend("topright", inset=c(-1.4,0), legend=revVec(colorCodeSmall[,1]), fill=revVec(colorCodeSmall[,2]))
```

### Unconsidered reads

In above statistics, what is the ratio of reads that is not considered compared to the raw data/trimmed data. Negative values mean that the reads have been counted repeated times. 

```{r}
# DO THIS WIUTH THE MATRIX FROM ABOVE!!!!

unconsideredReads <- rawReads_perSample - apply(overall_stats,2,sum)
#for(i in 1:length(samples)) unconsideredReads[i] <- conc.reads[i] - sum(fc.expr.stats[-12,(i+1)]) - sum(star.hairpin_species[,(i+1)]) - sum(star.mature_species[,(i+1)]) - trna.mapped.reads[i] - phix.mapped.reads[i]

barplot(unconsideredReads, las=2)
```

# Analyses

## Clustering

### hclust based on star.mature_species.rpkm

```{r}
cluster.data <- star.mature_species.rpkm
colnames(cluster.data) <- gsub("_star_mature_species.txt", "", colnames(cluster.data))
star.mature_species.rpkm.dist <- as.dist(1-cor(as.matrix(cluster.data)))
hc <- hclust(star.mature_species.rpkm.dist)           
plot(hc)  
```

### hclust based on  star.protein_coding.rpkm

```{r}
cluster.data <- star.protein_coding.rpkm
colnames(cluster.data) <- gsub("_star_mature_species.txt", "", colnames(cluster.data))
star.mature_species.rpkm.dist <- as.dist(1-cor(as.matrix(cluster.data)))
hc <- hclust(star.mature_species.rpkm.dist)           
plot(hc)  
```

### hclust based on novel.rpkm

```{r}
cluster.data <- novel.rpkm
star.novel.rpkm.dist <- as.dist(1-cor(as.matrix(cluster.data)))
hc <- hclust(star.novel.rpkm.dist)           
plot(hc)  
```

## Dimension reduction

### PCA - Mature_Species.fa (STAR)

```{r performPCA}
# This is just quick and dirty, find later a nice palette to chose from...
color <- grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]
color.pre <- c('#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#42d4f4', '#f032e6', '#bfef45', '#fabed4', '#469990', '#dcbeff', '#9A6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1', '#000075', '#a9a9a9', '#ffffff', '#000000')

expr.PCA <- prcomp(t(star.mature_species.rpkm))
expr.PCA.mature_species <- expr.PCA
if(sampleInfo.avail){
  pca.colours <- sampleInfo
  for(i in 1:nrow(pca.colours)){
    pca.colours[grep(sampleInfo$sampleID[i], colnames(star.mature_species.rpkm)),] <- sampleInfo[i,]
  }
} else {
  pca.colours <- "black"
}
  
  
pca.legend <- list()

if(sampleInfo.avail){
if(ncol(pca.colours)>1){
 for(i in 2:ncol(pca.colours)){
   group_table <- table(pca.colours[,i])
   n_groups <- length(group_table)
   set.seed(453)
   getPalette <- colorRampPalette(sample(color, n_groups,replace=F))
   groupPalette <- getPalette(n_groups)
   if(n_groups<20){
     groupPalette <- color.pre[1:n_groups]
   }
   
   names(groupPalette) <- names(group_table)
   pca.legend[[i-1]] <- groupPalette
   for(j in 1:length(groupPalette)){
      pca.colours[pca.colours[,i]==names(groupPalette)[j],i] <- groupPalette[j]
   }
 }  
}
  
}


```

This is just the plain PCA, without using any colouring schemes.

```{r}
palette("default")
pairs(expr.PCA$x[,1:3])
```

```{r}
names(expr.PCA$x[,1])[which(expr.PCA$x[,1]>0)]
```

```{r, results="asis"}
if(sampleInfo.avail){
  if(ncol(sampleInfo)>1){
    for(i in 2:ncol(sampleInfo)){
      tmpTitle <- paste("### 3C: ",colnames(sampleInfo)[i],"\n")
      cat(sprintf(tmpTitle))
      pairs(expr.PCA$x[,1:3], col=pca.colours[,i], pch=20, oma=c(3,3,3,15))
      par(xpd=TRUE)
      legend("topright", fill=pca.legend[[i-1]], legend=names(pca.legend[[i-1]]))
      par(xpd=FALSE)
      cat(sprintf("\n\n"))
    }
  }  
}
```

```{r}
cols <- min(ncol(expr.PCA$x),10)
pairs(expr.PCA$x[,1:cols])
```

```{r, results="asis"}
if(sampleInfo.avail){
  if(ncol(sampleInfo)>1){
  for(i in 2:ncol(sampleInfo)){
    tmpTitle <- paste("### 10C: ",colnames(sampleInfo)[i],"\n")
    cat(sprintf(tmpTitle))
    pairs(expr.PCA$x[,1:cols], col=pca.colours[,i], pch=20, oma=c(3,3,3,15))
    par(xpd=TRUE)
    legend("bottomright", fill=pca.legend[[i-1]], legend=names(pca.legend[[i-1]]))
    par(xpd=FALSE)
    cat(sprintf("\n\n"))
  }
  }
}
```


### PCA - Reference-protein_coding (STAR)

```{r performPCA_protein_coding}
expr.PCA <- prcomp(t(star.protein_coding.rpkm))
expr.PCA.protein_coding <- expr.PCA
```

This is just the plain PCA, without using any colouring schemes.

```{r}
palette("default")
pairs(expr.PCA$x[,1:3])
```

```{r}
names(expr.PCA$x[,1])[which(expr.PCA$x[,1]>0)]
```

```{r, results="asis"}
if(sampleInfo.avail){
  if(ncol(sampleInfo)>1){
    for(i in 2:ncol(sampleInfo)){
      tmpTitle <- paste("### 3C: ",colnames(sampleInfo)[i],"\n")
      cat(sprintf(tmpTitle))
      pairs(expr.PCA$x[,1:3], col=pca.colours[,i], pch=20, oma=c(3,3,3,15))
      par(xpd=TRUE)
      legend("bottomright", fill=pca.legend[[i-1]], legend=names(pca.legend[[i-1]]))
      par(xpd=FALSE)
      cat(sprintf("\n\n"))
    }
  }  
}
```

```{r}
cols <- min(ncol(expr.PCA$x),10)
pairs(expr.PCA$x[,1:cols])
```

```{r, results="asis"}
if(sampleInfo.avail){
  if(ncol(sampleInfo)>1){
for(i in 2:ncol(sampleInfo)){
  tmpTitle <- paste("### 10C: ",colnames(sampleInfo)[i],"\n")
  cat(sprintf(tmpTitle))
  pairs(expr.PCA$x[,1:cols], col=pca.colours[,i], pch=20, oma=c(3,3,3,15))
  par(xpd=TRUE)
  legend("topright", fill=pca.legend[[i-1]], legend=names(pca.legend[[i-1]]))
  par(xpd=FALSE)
  cat(sprintf("\n\n"))
}
}
}
```


### PCA - Novel predictions (STAR)

```{r performPCA_novel}
expr.PCA <- prcomp(t(novel.rpkm))
expr.PCA.novel <- expr.PCA
```

This is just the plain PCA, without using any colouring schemes.

```{r}
palette("default")
pairs(expr.PCA$x[,1:3])
```

```{r}
names(expr.PCA$x[,1])[which(expr.PCA$x[,1]>0)]
```

```{r, results="asis"}
if(sampleInfo.avail){
  if(ncol(sampleInfo)>1){
    for(i in 2:ncol(sampleInfo)){
      tmpTitle <- paste("### 3C: ",colnames(sampleInfo)[i],"\n")
      cat(sprintf(tmpTitle))
      pairs(expr.PCA$x[,1:3], col=pca.colours[,i], pch=20, oma=c(3,3,3,15))
      par(xpd=TRUE)
      legend("bottomright", fill=pca.legend[[i-1]], legend=names(pca.legend[[i-1]]))
      par(xpd=FALSE)
      cat(sprintf("\n\n"))
    }
  }  
}
```

```{r}
cols <- min(ncol(expr.PCA$x),10)
pairs(expr.PCA$x[,1:cols])
```

```{r, results="asis"}
if(sampleInfo.avail){
  if(ncol(sampleInfo)>1){
for(i in 2:ncol(sampleInfo)){
  tmpTitle <- paste("### 10C: ",colnames(sampleInfo)[i],"\n")
  cat(sprintf(tmpTitle))
  pairs(expr.PCA$x[,1:cols], col=pca.colours[,i], pch=20, oma=c(3,3,3,15))
  par(xpd=TRUE)
  legend("topright", fill=pca.legend[[i-1]], legend=names(pca.legend[[i-1]]))
  par(xpd=FALSE)
  cat(sprintf("\n\n"))
}
}
}
```

### ICS - Mature_Species.fa (STAR)
```{r, results="asis"}
cols <- min(ncol(expr.PCA.mature_species$x),10)
FOBI <- ics(expr.PCA.mature_species$x[,1:cols])
if(sampleInfo.avail){
if(ncol(sampleInfo)>1){
for(i in 2:ncol(sampleInfo)){
  tmpTitle <- paste("### ",colnames(sampleInfo)[i],"\n")
  cat(sprintf(tmpTitle))
  plot(FOBI,col=pca.colours[,i], pch=20, oma=c(3,3,3,15))
  par(xpd=TRUE)
  legend("bottomright", fill=pca.legend[[i-1]], legend=names(pca.legend[[i-1]]))
  par(xpd=FALSE)
  cat(sprintf("\n\n"))
}  
}} else {
   plot(FOBI, pch=20)
}
```



### ICS - Reference.protein_coding (STAR)
```{r, eval=FALSE, results="asis"}
cols <- min(ncol(expr.PCA$x),10)
FOBI <- ics(expr.PCA$x[,1:cols])
if(sampleInfo.avail){
  if(ncol(sampleInfo)>1){
  for(i in 2:ncol(sampleInfo)){
    tmpTitle <- paste("### ",colnames(sampleInfo)[i],"\n")
    cat(sprintf(tmpTitle))
    plot(FOBI, col=pca.colours[,i], pch=20, oma=c(3,3,3,15))
    par(xpd=TRUE)
    legend("bottomright",fill=pca.legend[[i-1]], legend=names(pca.legend[[i-1]]))
    par(xpd=FALSE)
    cat(sprintf("\n\n"))
  }  
}
  }else {
   plot(FOBI, pch=20)
}


```

### t-SNE - Mature_species.fa (STAR)

First, the PCA based t-SNE run (using the PCA-based reduced data as input)

```{r, results="asis"}
cols <- min(ncol(expr.PCA.mature_species$x),10)
TSNEout <- tsne(expr.PCA.mature_species$x[,1:cols], k=5)
if(sampleInfo.avail){
  if(ncol(sampleInfo)>1){
  for(i in 2:ncol(sampleInfo)){
  tmpTitle <- paste("### ",colnames(sampleInfo)[i],"(PCA-based)\n")
  cat(sprintf(tmpTitle))
  plot(TSNEout, col=pca.colours[,i], pch=20, oma=c(3,3,3,15))
  par(xpd=TRUE)
  legend("bottomright", fill=pca.legend[[i-1]], legend=names(pca.legend[[i-1]]))
  par(xpd=FALSE)
  cat(sprintf("\n\n"))
  }
}
  }else {
   plot(TSNEout, pch=20)
}
```

And then the run for the original data

```{r, eval=FALSE, results="asis"}
cols <- min(ncol(expr.PCA.mature_species$x),10)
TSNEout <- tsne(star.mature_species.rpkm, k=5)
if(sampleInfo.avail){
  if(ncol(sampleInfo)>1){
  for(i in 2:ncol(sampleInfo)){
    tmpTitle <- paste("### ",colnames(sampleInfo)[i],"(Orig.-data based)\n")
    cat(sprintf(tmpTitle))
    plot(TSNEout, col=pca.colours[,i], pch=20, oma=c(3,3,3,15))
    par(xpd=TRUE)
    legend("bottomright",fill=pca.legend[[i-1]], legend=names(pca.legend[[i-1]]))
    par(xpd=FALSE)
    cat(sprintf("\n\n"))
  }
}
  }else {
   plot(TSNEout, pch=20)
}
```

### t-SNE - Reference-protein_coding (STAR)
First for the PCA reduced input data
```{r, results="asis"}
cols <- min(ncol(expr.PCA.protein_coding$x),10)
TSNEout <- tsne(expr.PCA.protein_coding$x[,1:cols], k=5)
if(sampleInfo.avail){
  if(ncol(sampleInfo)>1){
  for(i in 2:ncol(sampleInfo)){
    tmpTitle <- paste("### ",colnames(sampleInfo)[i],"(PCA-based)\n")
    cat(sprintf(tmpTitle))
    plot(TSNEout, col=pca.colours[,i], pch=20, oma=c(3,3,3,15))
    par(xpd=TRUE)
    legend("bottomright", fill=pca.legend[[i-1]], legend=names(pca.legend[[i-1]]))
    par(xpd=FALSE)
    cat(sprintf("\n\n"))
  }
}
  }else {
   plot(TSNEout, pch=20)
}
```

And then for the original data as well

```{r, eval=FALSE, results="asis"}
cols <- min(ncol(expr.PCA.protein_coding$x),10)
TSNEout <- tsne(star.protein_coding.rpkm, k=5)
if(sampleInfo.avail){
if(ncol(sampleInfo)>1){
for(i in 2:ncol(sampleInfo)){
  tmpTitle <- paste("### ",colnames(sampleInfo)[i],"(Orig.data based)\n")
  cat(sprintf(tmpTitle))
  plot(TSNEout, col=pca.colours[,i], pch=20, oma=c(3,3,3,15))
  par(xpd=TRUE)
  legend("bottomright", fill=pca.legend[[i-1]], legend=names(pca.legend[[i-1]]))
  par(xpd=FALSE)
  cat(sprintf("\n\n"))
}
}
} else {
   plot(TSNEout, pch=20)
}
```
### Kernel PCA - Mature_species.fa (STAR)
PCA-based data
```{r}
# Kernel PCA
cols <- min(min(dim(expr.PCA.mature_species$x)),10)-1
KPCAres <- kpca(expr.PCA.mature_species$x[,1:cols])
```

```{r, results="asis"}
if(sampleInfo.avail){
if(ncol(sampleInfo)>1){
  for(i in 2:ncol(sampleInfo)){
      tmpTitle <- paste("### ",colnames(sampleInfo)[i],"\n")
      cat(sprintf(tmpTitle))
      pairs(rotated(KPCAres)[,1:cols], col=pca.colours[,i], pch=20, oma=c(3,3,3,15))
      par(xpd=TRUE)
      legend("bottomright", fill=pca.legend[[i-1]], legend=names(pca.legend[[i-1]]))
      par(xpd=FALSE)
      cat(sprintf("\n\n"))
  }
} 
  }else {
   ndim <- min(ncol(rotated(KPCAres)), 10)
   plot(rotated(KPCAres)[,1:ndim], pch=20)
}
```
Original data
```{r, eval=FALSE}
# Kernel PCA
cols <- min(min(dim(expr.PCA.mature_species$x)),10)-1
KPCAres <- kpca(star.mature_species.rpkm)
```

```{r, eval=FALSE, results="asis"}
if(sampleInfo.avail){
if(ncol(sampleInfo)>1){
  for(i in 2:ncol(sampleInfo)){
      tmpTitle <- paste("### ",colnames(sampleInfo)[i],"\n")
      cat(sprintf(tmpTitle))
      pairs(rotated(KPCAres)[,1:cols], col=pca.colours[,i], pch=20, oma=c(3,3,3,15))
      par(xpd=TRUE)
      legend("bottomright", fill=pca.legend[[i-1]], legend=names(pca.legend[[i-1]]))
      par(xpd=FALSE)
      cat(sprintf("\n\n"))
  }
}
} else {
   ndim <- min(ncol(rotated(KPCAres)), 10)
   plot(rotated(KPCAres)[,1:ndim], pch=20)
}
```
### Kernel PCA - Reference-protein_coding (STAR)
PCA-based data
```{r}
# Kernel PCA
cols <- min(min(dim(expr.PCA.protein_coding$x)),10)-1
KPCAres <- kpca(expr.PCA.protein_coding$x[,1:cols])
```

```{r, results="asis"}
if(sampleInfo.avail){
if(ncol(sampleInfo)>1){
  for(i in 2:ncol(sampleInfo)){
      tmpTitle <- paste("### ",colnames(sampleInfo)[i],"(PCA based data)\n")
      cat(sprintf(tmpTitle))
      pairs(rotated(KPCAres)[,1:cols], col=pca.colours[,i], pch=20, oma=c(3,3,3,15))
      par(xpd=TRUE)
      legend("bottomright", fill=pca.legend[[i-1]], legend=names(pca.legend[[i-1]]))
      par(xpd=FALSE)
      cat(sprintf("\n\n"))
  }
}
} else {
   ndim <- min(ncol(rotated(KPCAres)), 10)
   plot(rotated(KPCAres)[,1:ndim], pch=20)
}
```


original data
```{r, eval=FALSE}
# Kernel PCA
cols <- min(min(dim(expr.PCA.protein_coding$x)),10)-1
KPCAres <- kpca(star.protein_coding.rpkm)
```

```{r, eval=FALSE, results="asis"}
if(sampleInfo.avail){
if(ncol(sampleInfo)>1){
  for(i in 2:ncol(sampleInfo)){
      tmpTitle <- paste("### ",colnames(sampleInfo)[i],"(Orig.based data)\n")
      cat(sprintf(tmpTitle))
      pairs(rotated(KPCAres)[,1:cols], col=pca.colours[,i], pch=20, oma=c(3,3,3,15))
      par(xpd=TRUE)
      legend("bottomright", fill=pca.legend[[i-1]], legend=names(pca.legend[[i-1]]))
      par(xpd=FALSE)
      cat(sprintf("\n\n"))
  }
}
} else {
   ndim <- min(ncol(rotated(KPCAres)), 10)
   plot(rotated(KPCAres)[,1:ndim], pch=20)
}
```

### Locally linear embedding (LLE) - Mature_species.fa (STAR)
PCA based data
```{r}
# LLE
cols <- min(ncol(expr.PCA.mature_species$x),10)
lleres <- lle(expr.PCA.mature_species$x[,1:cols], m=7, k=17, v=0.99)
```

```{r, results="asis"}
if(sampleInfo.avail){
  if(ncol(sampleInfo)>1){
  for(i in 2:ncol(sampleInfo)){
      tmpTitle <- paste("### ",colnames(sampleInfo)[i],"\n")
      cat(sprintf(tmpTitle))
      pairs(lleres$Y[,1:5], col=pca.colours[,i], pch=20, oma=c(3,3,3,15))
      par(xpd=TRUE)
      legend("bottomright", fill=pca.legend[[i-1]], legend=names(pca.legend[[i-1]]))
      par(xpd=FALSE)
      cat(sprintf("\n\n"))
  }
  }
} else {
   plot(lleres$Y[,1:5], pch=20)
}
```

Orig-based data

```{r, eval=FALSE}
# LLE
cols <- min(ncol(expr.PCA.mature_species$x),10)
lleres <- lle(star.mature_species.rpkm, m=7, k=17, v=0.99)
```

```{r, eval=FALSE, results="asis"}
if(sampleInfo.avail){
  if(ncol(sampleInfo)>1){
  for(i in 2:ncol(sampleInfo)){
      tmpTitle <- paste("### ",colnames(sampleInfo)[i],"\n")
      cat(sprintf(tmpTitle))
      pairs(lleres$Y[,1:5], col=pca.colours[,i], pch=20, oma=c(3,3,3,15))
      par(xpd=TRUE)
      legend("bottomright", fill=pca.legend[[i-1]], legend=names(pca.legend[[i-1]]))
      par(xpd=FALSE)
      cat(sprintf("\n\n"))
  }
  }
} else {
   plot(lleres$Y[,1:5], pch=20)
}
```



### Locally linear embedding (LLE) - Reference-protein_coding (STAR)

PCA based data
```{r}
# LLE
cols <- min(ncol(expr.PCA.protein_coding$x),10)
lleres <- lle(expr.PCA.protein_coding$x[,1:cols], m=7, k=17, v=0.99)
```

```{r, results="asis"}
if(sampleInfo.avail){
  if(ncol(sampleInfo)>1){
  for(i in 2:ncol(sampleInfo)){
      tmpTitle <- paste("### ",colnames(sampleInfo)[i],"\n")
      cat(sprintf(tmpTitle))
      pairs(lleres$Y[,1:5], col=pca.colours[,i], pch=20, oma=c(3,3,3,15))
      par(xpd=TRUE)
      legend("bottomright", fill=pca.legend[[i-1]], legend=names(pca.legend[[i-1]]))
      par(xpd=FALSE)
      cat(sprintf("\n\n"))
  }
  }
} else {
   plot(lleres$Y[,1:5], pch=20)
}
```


Original based data
```{r, eval=FALSE}
# LLE
cols <- min(ncol(expr.PCA.protein_coding$x),10)
lleres <- lle(star.protein_coding.rpkm, m=7, k=17, v=0.99)
```

```{r, eval=FALSE, results="asis"}
if(sampleInfo.avail){
  if(ncol(sampleInfo)>1){
  for(i in 2:ncol(sampleInfo)){
      tmpTitle <- paste("### ",colnames(sampleInfo)[i],"\n")
      cat(sprintf(tmpTitle))
      pairs(lleres$Y[,1:5], col=pca.colours[,i], pch=20, oma=c(3,3,3,15))
      par(xpd=TRUE)
      legend("bottomright", fill=pca.legend[[i-1]], legend=names(pca.legend[[i-1]]))
      par(xpd=FALSE)
      cat(sprintf("\n\n"))
  }
  }
} else {
   plot(lleres$Y[,1:5], pch=20)
}
```

# Runtime checks
Add here:
* Table the bases of each inputer reference, in case they contain "U"'s, throw a warning and a suggestion how to fix it to "T"